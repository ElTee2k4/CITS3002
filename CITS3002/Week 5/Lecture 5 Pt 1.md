**Network Layer (NL):**

- The DLL has the responsibility of reliably transmitting *frames* across along a single wire (or wireless) link.
- Network Layers responsibility is to get packets from an actual source machine to a destination machine, with many alternating steps along the way.
- Network Layer deals with end-to-end transmission, meaning that multiple nodes are able to communicate with one another even if they are not connected to each other.
	- End-to-end as responsibilities, negotiation etc are generated by the sender and are checked by the receiver in both network layers multiple hops away from each other.
- NOTE: A hop refers to the movement of data from one network device to another as it traverses a network.
	- 1 hop could be from device to router, then to the ISP would be 2 hops and then through several ISPs would add more hops until it reaches the destination router and server.
- Network Layer believes that they are talking to their peer network layer across the network. In reality, packets from the network layer are pushed down to the DLL and traverses the rest and the start of the receiver protocol stack.
- When multiple nodes(and thus hops) are involved, the nodes between sender and receiver are also involved in transmission in a supportive. Intermediate nodes choose the correct path to take.

*Network Layer basics:*

- *Formal Example throughout this lesson:* PERTH TO SYDNEY - Perth gives message to Adelaide and then to Melbourne and to either direct to Sydney or Canberra.
- Adelaide has two links between Perth and Melbourne. Data that flows on one link is presumably for a destination that exists on the other link. They can check this by looking at the address field in the packet header.
	- A packet that isn't for the node that it was sent too and that only has one link, example Perth, is an error. 
	- You could send it back but this could result in duplicate messages bouncing back and forth from the sender (No route to host error message).
	- Rather then sending message back again, it sends back an error message that can be understood only by the network layer. 
- Error traffic is generated by this layer and only understood by the network layer. This message is only meant for the peer network layer.

*Objectives:*

- Independence of processor/communication technology, independence of the number, type and topology of the subnets and to provide a uniform addressing scheme for all hosts in the network.

*Dynamic nature of nodes:*

- Intermediate nodes will need to see the network headers so that they can work out where the eventual destination is. Snooping on network headers by non-related nodes can serve as a useful mechanism for dynamic networks to adapt data paths in response to changes in the best traversal path.
	- Non-related nodes use this information to determine the best path in terms of severed or congested links, increased prices etc.
- Any particular node, however, cannot possibly know everything about any node. Every node knows some aspects about its neighbors and those neighbors will know about their neighbors.

*Neighboring and learning information from nodes:*

- Every node knows about itself, its links, find out who its neighbors are and find out the RTT between itself and a neighbor. Thus, a node may be able to learn about the wider network by learning about its neighbors neighbors. 
	- Adelaide could learn about Sydney from Melbourne, who is a neighbor of both.
- This information, however, takes time to get the the current node.
	- By the time the information has gotten to the sender, the data could become out of date. 
- Most network nodes users use only have a single link, meaning that most nodes don't have to deal with many of these issues.
	- Thus, it is mostly interior nodes, such as ISPs, that need all of the complexity in their routing decisions. These nodes have default options which are mostly right until an error occurs.
	- If you don't know how to get to a node, you just use the default link transfer path.

*Design of network layer:*

- It needs to be as independent of all constraints possible (such as the OS, type of topology such as WiFi or Ethernet, shape of the networks).
	- Although at times, it does need to know some physical capabilities of the physical medium it is transmitting on (such as upper bounds on speed and packet sizes)
- If devices connect to similar topologies, they might have to change the headers or structure of data. However, we try to simplify this process.

**Relationship between Hosts and Subnets:**

- Network Layer software runs in dedicated devices called routers and the Transport Layer runs in the hosts.
	- Departments in a company are connected together by a form of router which distributes bandwidth across the nodes. This differs from every node being connected to each other.

**Implication for Data Link Layer software:**

- Network Layer is above DLL, which is the only method for the network layer to get rid of its packets.
- Having done its packet routing in the network layer, it has to tell DLL what link the network layer is referring to in its routing decision. This is because every link has a DLL attached to it.
- Different DLLs might run on different speeds and have different topologies attached to it. As such, the different DLLs on different links (although code is the same) need to be very independent of each other.
	- We could also mix different implementations of DLL protocols (such as one having stop and wait whilst another has sliding window).

**Responsibilities of the Network layer:**

- NOTE: End to end in networking refers to the principle that the communication between two endpoints should be handled exclusively by those endpoints.
- Each node can be responsible for everything from handling its own links to managing the network topology. Because the connection is end-to-end, a lot of these requirements are handled by sender and receiver. The requirements are of three types:
	- Source and Destination functions: end to end protocols, network layer interface, fragmentation and reassembly of messages
	- Store and forward functions: Choice of best route for packets, local flow control
	- Network-wide management functions: Network flow control, topological awareness and modification and network performance measurement and monitoring.
- Network, data link and physical are typically all built into the hardware of a network layer.

*Packet fragmentation and reassembly:*

![[Pasted image 20240404090756.png]]

- **Fragmentation:** When a message is too large to be transmitted in a single packet, it needs to be divided into smaller units called packets at the source node. 
	- Network Layer needs to ask the DLL what is the biggest size data that it can handle (which is based on what the biggest payload the physical layer can handle).
	- Fragments will also depend on the size of the NL header, where every fragment needs one (and thus using more bandwidth on just headers)
- These packets are transmitted through the network independently until they reach the destination node, where they are reassembled back into the original message.
	- Packets are able to do this due to their headers carrying information pertaining to their fragmented nature.
- Optimal size of fragments depends on factors such as bandwidth, latency, characteristics of the data being transmitted.
- Compression also works but this is usually done in higher layers then network layer.

*Fragmentation requirements:*

- There is either fixed sized fragmentation or fill up every frame across the physical layer and then have one small packet at the end (variable-sized).
- NL tells the receiving NL the size of the entire message and that the current fragment is only a fraction of the larger message. NL also numbers and sequences the fragments to ensure that the receiver knows what is coming.
	- This is so the receiver can buffer the correct amount of data for the payload that is incoming. Also, packet loss can be detected if this is done.
	- Sequencing the packets are important as the packets may not come in order and the receiver is able to detect this if the packets are numbered. 
- The NL needs to send all fragments combined as one together as the Transport Layer didn't know of the fragmentation that occurred.

![[fragmentation.gif]]

- As NL gets to use a certain link, it might choose to send different fragments on different paths, leading to unordered information. This is another reason why reassembly must occur.

**NL Header Management:**

- NL Header is created in the source node, examined in intermediate nodes and removed of in the destination node.
- The network layer headers typically contain:
	- Source and destination addresses
	- Packet size
	- Message number (and possible fragment number within that message)
	- Several control bits indicating whether packet is 'user-data' or control packet
	- Flow control information (permission to send additional messages, flags to change rate of flow)
	- Packet priority
- The NL Header cannot be encrypted as it contains this important information which is vital for non-inclusive nodes to access. Thus, we need to either trust the non-inclusive nodes or own the nodes that the message goes through.

**Path of frames and packets:**

- There becomes an explosion in the amount of frames/packets that must traverse through lower layers.

![[nlpath.gif]]

- A is transmitting to D. Everything that crosses the network involves a payload, NL header and DLL header.
	- Each network stack needs to decide if the message is meant for that node and if it isn't, it has to push it back down and send it to the next node.
	- Each network stack needs to send an ack back to the previous node who received the message.
- The network layer at D sends an network layer ack back to A to acknowledge that it received the message, which also has to traverse through all intermediate nodes.
- This process consumes a large amount of bandwidth.

**Two contending network layer schemes:**

*Connection-based service:* 

- Steps for connectionless are as follows:
	- Transport layer establishes a "semi-permanent" connection between source and destination.
		- Called a virtual circuit, providing a **dedicated** path for data to travel.
	- The two Transport Layers then agree about the *type and quality of service* that is required and will be available.
		- Parameters such as bandwidth, latency, reliability and priority are discussed.
	- Connection then occurs between the two nodes in a duplex fashion.
	- Connection is closed by both parties.
	- Each routing device along the path of the virtual circuit maintains tables that map pairs of source and virtual circuit members to destination and virtual circuit members.
- Historically, the virtual circuit cost of establishing a physical link between source and destination determined the cost of a telephone call.
	- By establishing call between Perth and Sydney, there are multiple wires connected together by humans. 
	- However, sender and receiver owned the wires that connected the two, preventing others from making a call, meaning that call wires were dedicated.

*Connectionless service:*

- Each host operates in a connectionless fashion in which streams of information is moved between source and destination without a permanent connection between them.
- Each packet moves independently of all previous packets between the same source and destination machines - with packets potentially taking different routes.
- Error processing is 'relinquished' to the Transport Layer as he hosts must perform this task.
- In the packet header, the full destination and source address will be written.
	- The initial packet is destined for a node 1 hop away. this node reads the header and sends it on a designated path. It continues like this until the destination.
	- This means that every message has a source and destination and we use the destination to decide which path to take for the next hop.

